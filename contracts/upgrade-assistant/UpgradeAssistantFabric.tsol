// SPDX-License-Identifier: UNLICENSED
pragma ton-solidity >= 0.57.1;

import "../interfaces/upgrade-assistant/IUpgradeAssistantFabric.tsol";
import "../interfaces/upgrade-assistant/IUpgradeAssistantBatch.tsol";
import "../interfaces/IVaultTokenRoot_V1.tsol";
import "./UpgradeAssistantBatch.tsol";
import {
    UpgradeAssistantConstants as constants
} from "./UpgradeAssistantConstants.tsol";

import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "@broxus/contracts/contracts/access/InternalOwner.tsol";
import "@broxus/contracts/contracts/utils/RandomNonce.tsol";

import "../tip3/interfaces/ITransferableOwnership.tsol";


contract UpgradeAssistantFabric is IUpgradeAssistantFabric, InternalOwner, RandomNonce {
    address public root;
    uint public worker;
    uint32 public batches;
    uint32 public batches_done;
    uint32 public batches_deployed;
    uint128 public deploy_batch_value;
    TvmCell public upgrade_assistant_batch_code;

    modifier onlyBatch(uint32 nonce) {
        require(msg.sender == _deriveBatch(nonce));

        _;
    }

    modifier reserve() {
        tvm.rawReserve(address(this).balance - msg.value, 2);

        _;
    }

    modifier onlySelfCall() {
        require(msg.sender == address(this));

        _;
    }

    modifier reserveMinBalance() {
        tvm.rawReserve(constants.BATCH_INITIAL_BALANCE, 2);

        _;
    }

    function deployBatches() external override onlySelfCall reserveMinBalance {
        tvm.accept();

        _deployBatches();
    }

    function _deployBatches() internal {
        uint32 batches_left = batches - batches_deployed;
        uint32 batches_to_deploy = math.min(batches_left, constants.DEPLOY_BATCHES_PER_TX);

        for (uint32 batch_id = 0; batch_id < batches_to_deploy; batch_id++) {
            address batch = _deployBatch(batch_id + batches_deployed);

            emit NewBatch(batch_id, batch);
        }

        batches_deployed += batches_to_deploy;

        if (batches_deployed < batches) {
            IUpgradeAssistantFabric(address(this)).deployBatches{
                flag: MsgFlag.ALL_NOT_RESERVED,
                value: 0,
                bounce: false
            }();
        }
    }

    constructor(
        address owner_,
        uint worker_,
        address root_,
        TvmCell upgrade_assistant_batch_code_,
        uint32 batches_,
        uint128 deploy_batch_value_
    ) public {
        tvm.accept();

        setOwnership(owner_);

        worker = worker_;
        root = root_;
        upgrade_assistant_batch_code = upgrade_assistant_batch_code_;
        batches = batches_;
        batches_deployed = 0;

        require(deploy_batch_value_ >= constants.BATCH_INITIAL_BALANCE);
        deploy_batch_value = deploy_batch_value_;

        _deployBatches();
    }

    function _deployBatch(uint32 nonce) internal view returns(address) {
        return new UpgradeAssistantBatch{
            value: deploy_batch_value,
            flag: 0,
            code: upgrade_assistant_batch_code,
            pubkey: 0,
            varInit: {
                fabric: address(this),
                nonce: nonce
            }
        }(worker, owner);
    }

    function deriveBatch(uint32 batch_id) external view returns (address) {
        return _deriveBatch(batch_id);
    }

    function _deriveBatch(uint32 batch_id) internal view returns (address) {
        TvmCell stateInit = tvm.buildStateInit({
            contr: UpgradeAssistantBatch,
            varInit: {
                fabric: address(this),
                nonce: batch_id
            },
            pubkey: 0,
            code: upgrade_assistant_batch_code
        });

        return address(tvm.hash(stateInit));
    }

    function upgrade() external override onlyOwner reserve {
        uint128 value_per_batch = msg.value / batches - 0.1 ever;

        for (uint32 batch_id = 0; batch_id < batches; batch_id++) {
            address batch = _deriveBatch(batch_id);

            IUpgradeAssistantBatch(batch).upgrade{
                value: value_per_batch,
                bounce: true,
                flag: 0
            }();
        }
    }

    function acceptUpgrade(
        uint32 nonce,
        address[] wallets
    ) external override onlyBatch(nonce) reserve {
        IVaultTokenRoot_V1(root).upgradeWallets{
            value: 0,
            bounce: true,
            flag: MsgFlag.REMAINING_GAS
        }(wallets, constants.ACCEPT_UPGRADE_VALUE);
    }

    function revokeOwnership() external override {
        ITransferableOwnership(root).transferOwnership{
            bounce: true,
            flag: MsgFlag.ALL_NOT_RESERVED,
            value: 0
        }(owner, msg.sender, emptyMap);
    }

    function finishUpgrade(
        uint32 nonce
    ) external override onlyBatch(nonce) {
        batches_done++;
    }

    function isDone() external view returns (bool done) {
        return (batches_done == batches);
    }

    function destroy() external onlyOwner {
        selfdestruct(owner);
    }
}
