pragma ton-solidity >= 0.39.0;
pragma AbiHeader expire;
pragma AbiHeader pubkey;


import "tip3/contracts/interfaces/IBurnableTokenWallet.tsol";
import "tip3/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
import "tip3/contracts/interfaces/ITokenWallet.tsol";
import "tip3/contracts/libraries/TokenErrors.tsol";

import "@broxus/contracts/contracts/utils/CheckPubKey.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";

import "./../libraries/ErrorCodes.tsol";
import "./../interfaces/IVault.tsol";


/**
    @notice Wrapped EVER / VENOM vault
*/
abstract contract Vault is
    IAcceptTokensTransferCallback,
    IVault,
    CheckPubKey
{
    uint128 constant public RECEIVE_SAFE_FEE = 1 ever;
    uint128 constant public DEPLOY_WALLET_VALUE = 0.05 ever;
    uint128 constant public INITIAL_BALANCE = 1 ever;

    bool public emergency;
    address public guardian;
    address public token_wallet;
    uint128 public total_wrapped;

    modifier emergencyDisabled() {
        require(!emergency, ErrorCodes.EMERGENCY_ENABLED);

        _;
    }

    modifier cashBack() {
        tvm.rawReserve(address(this).balance - msg.value, 2);
        _;
        msg.sender.transfer({ value: 0, flag: 129 });
    }

    modifier onlyOwner() {
        require(msg.sender == owner());

        _;
    }

    function __mint(uint128, address, uint128, address, bool, TvmCell) internal virtual {}
    function owner() internal virtual returns (address);

    function setGuardian(
        address _guardian
    ) external override onlyOwner cashBack {
        guardian = _guardian;
    }

    function setEmergency(
        bool _emergency
    ) external override cashBack {
        if (emergency == false) {
            require(msg.sender == owner(), TokenErrors.NOT_OWNER);
        } else {
            require(msg.sender == guardian || msg.sender == owner(), TokenErrors.NOT_OWNER);
        }

        emergency = _emergency;

        emit EmergencySet(_emergency);
    }

    /**
        @notice Drain odd EVERs
        @dev Can be called only by owner
        @param receiver Address to send odd EVERs to
    */
    function drain(
        address receiver
    ) external view onlyOwner {
        tvm.rawReserve(total_wrapped + INITIAL_BALANCE, 2);

        receiver.transfer({ value: 0, flag: 129 });
    }

    /**
        @notice Withdraw EVERs from the vault
        @dev Can be called only by owner
        @dev EVERs are send to the owner wallet
        @param amount How much EVERs to withdraw
    */
    function withdraw(
        uint128 amount
    ) external onlyOwner {
        updateTotalWrapped(-amount);

        tvm.rawReserve(total_wrapped + INITIAL_BALANCE, 2);

        owner().transfer({
            value: 0,
            bounce: false,
            flag: 128
        });
    }

    /**
        @notice Send EVERs to the vault without issuing wEVERs
        @dev Increases initial balance value
        so the granted EVERs won't be withdrawn on the wrapping / unwrapping
        @dev Be careful! Since you don't have WEVER tokens, you can't redeem granted EVERs
    */
    function grant(
        uint128 amount
    ) external override emergencyDisabled {
        require(amount <= msg.value + RECEIVE_SAFE_FEE, ErrorCodes.MSG_VALUE_TOO_LOW);

        updateTotalWrapped(amount);

        tvm.rawReserve(total_wrapped + INITIAL_BALANCE, 2);

        msg.sender.transfer({ value: 0, flag: 128 });
    }

    /**
        @notice Receive EVERs to wrap them into wTON.
        Allows to simply mint wEVERs by sending them directly to vault.
        @dev msg.value should be > RECEIVE_SAFE_FEE
        @dev Amount of minted tokens = msg.value - RECEIVE_SAFE_FEE
        @dev Rest of the EVERs will be sent back
    */
    receive() external emergencyDisabled {
        require(msg.value > RECEIVE_SAFE_FEE, ErrorCodes.MSG_VALUE_TOO_LOW);

        uint128 tokens = msg.value - RECEIVE_SAFE_FEE;

        updateTotalWrapped(tokens);

        tvm.rawReserve(total_wrapped + INITIAL_BALANCE, 2);

        TvmCell empty;

        __mint(
            tokens,
            msg.sender,
            DEPLOY_WALLET_VALUE,
            msg.sender,
            true,
            empty
        );
    }

    /**
        @notice Updates total wrapped amount
        @param change Change amount
    */
    function updateTotalWrapped(uint128 change) internal {
        total_wrapped += change;
    }

    /**
        @notice Internal function for minting wEVERs
        @dev Works since Vault is authorized for minting tokens
        @param tokens How much tokens to mint
        @param owner_address Token wallet owner address
        @param gas_back_address Address to send change
    */

    function wrap(
        uint128 tokens,
        address owner_address,
        address gas_back_address,
        TvmCell payload
    ) external override emergencyDisabled {
        require(
            msg.value >= tokens + RECEIVE_SAFE_FEE,
            ErrorCodes.MSG_VALUE_TOO_LOW
        );

        updateTotalWrapped(tokens);

        tvm.rawReserve(total_wrapped + INITIAL_BALANCE, 2);

        __mint(
            tokens,
            owner_address,
            DEPLOY_WALLET_VALUE,
            gas_back_address,
            true,
            payload
        );
    }

    /**
        @notice Receive wEVERs to burn them and release EVERs
        @dev Callback function from vault token wallet
        @dev EVERs will be sent to tokens sender
    */
    function onAcceptTokensTransfer(
        address tokenRoot,
        uint128 amount,
        address sender,
        address,
        address remainingGasTo,
        TvmCell payload
    ) override external {
        require(tokenRoot == address(this), ErrorCodes.WRONG_ROOT);
        require(msg.sender == token_wallet, ErrorCodes.WRONG_TOKEN_WALLET);

        // Return tokens in case of enabled emergency mode
        if (emergency) {
            ITokenWallet(token_wallet).transfer{
                value: 0,
                flag: MsgFlag.REMAINING_GAS,
                bounce: false
            }(
                amount,
                sender,
                DEPLOY_WALLET_VALUE,
                remainingGasTo,
                true,
                payload
            );
        } else {
            updateTotalWrapped(-amount);

            tvm.rawReserve(total_wrapped + INITIAL_BALANCE, 2);

            // Burn wEVERs
            IBurnableTokenWallet(token_wallet).burn{value: 0, flag: 128}(
                amount,
                remainingGasTo,
                sender,
                payload
            );
        }
    }
}
