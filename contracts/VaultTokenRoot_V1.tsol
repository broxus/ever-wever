pragma ton-solidity >= 0.57.1;
pragma AbiHeader expire;
pragma AbiHeader pubkey;

import "tip3/abstract/TokenRootTransferableOwnershipBase.tsol";
import "tip3/abstract/TokenRootBurnPausableBase.tsol";
import "tip3/abstract/TokenRootBurnableByRootBase.tsol";
import "tip3/abstract/TokenRootDisableableMintBase.tsol";
import "tip3/interfaces/IAcceptTokensTransferCallback.tsol";

import "tip3/interfaces/ITokenRootUpgradeable.tsol";
import "tip3/interfaces/ITokenWalletUpgradeable.tsol";
import "tip3/interfaces/IVersioned.tsol";
import "tip3/libraries/TokenErrors.tsol";
import "tip3/libraries/TokenMsgFlag.tsol";
import "tip3/libraries/TokenGas.tsol";
import "tip3/TokenWalletPlatform.tsol";

import "./interfaces/IVaultTokenRoot_V1.tsol";
import "./interfaces/IVaultTokenWallet_V1.tsol";
import "./libraries/ErrorCodes.tsol";



contract VaultTokenRoot_V1 is
    TokenRootTransferableOwnershipBase,
    TokenRootBurnPausableBase,
    TokenRootBurnableByRootBase,
    TokenRootDisableableMintBase,
    ITokenRootUpgradeable,
    IVaultTokenRoot_V1,
    IAcceptTokensTransferCallback
{
    uint256 static randomNonce_;
    address static deployer_;

    TvmCell static platformCode_;
    uint32 walletVersion_;

    // Legacy vault variables
    address public legacy_vault;
    address public legacy_vault_token_wallet;
    uint128 public legacy_vault_reserves;

    constructor() public {
        if (msg.pubkey() != 0) {
            require(msg.pubkey() == tvm.pubkey() && deployer_.value == 0, TokenErrors.WRONG_ROOT_OWNER);
            tvm.accept();
        } else {
            require(deployer_.value != 0 && msg.sender == deployer_ ||
                deployer_.value == 0 && msg.sender == rootOwner_, TokenErrors.WRONG_ROOT_OWNER);
        }

        totalSupply_ = 0;
        mintDisabled_ = false;
        burnByRootDisabled_ = false;
        burnPaused_ = false;
        walletVersion_ = 1;

        tvm.rawReserve(_targetBalance(), 0);
        _transfer(rootOwner_, TokenMsgFlag.ALL_NOT_RESERVED);
    }

    function setLegacyVault(
        address legacy_vault_
    ) external override reserve onlyRootOwner {
        legacy_vault = legacy_vault_;
        legacy_vault_token_wallet = _getExpectedWalletAddress(legacy_vault);

        _transfer(msg.sender, TokenMsgFlag.ALL_NOT_RESERVED);
    }

    function mint(
        uint128 amount,
        address recipient,
        uint128 deployWalletValue,
        address remainingGasTo,
        bool notify,
        TvmCell payload
    )
        override(TokenRootBase,ITokenRoot)
        external
        virtual
    {
        require(
            rootOwner_.value != 0 && (rootOwner_ == msg.sender || msg.sender == legacy_vault),
            TokenErrors.NOT_OWNER
        );
        require(_mintEnabled(), TokenErrors.MINT_DISABLED);
        require(amount > 0, TokenErrors.WRONG_AMOUNT);
        require(recipient.value != 0, TokenErrors.WRONG_RECIPIENT);

        tvm.rawReserve(_reserve(), 0);

        if (msg.sender == legacy_vault) {
            legacy_vault_reserves += amount;

            _mint(
                amount,
                recipient,
                deployWalletValue,
                remainingGasTo,
                notify,
                payload
            );
        } else {
            _transferTokens(
                amount,
                recipient,
                deployWalletValue,
                remainingGasTo,
                notify,
                payload
            );
        }
    }

    function _transferTokens(
        uint128 amount,
        address recipient,
        uint128 deployWalletValue,
        address remainingGasTo,
        bool notify,
        TvmCell payload
    ) internal {
        TvmCell stateInit = _buildWalletInitData(recipient);

        address recipientWallet;

        if (deployWalletValue > 0) {
            recipientWallet = _deployWallet(stateInit, deployWalletValue, remainingGasTo);
        } else {
            recipientWallet = address(tvm.hash(stateInit));
        }

        totalSupply_ += amount;

        ITokenWallet(recipientWallet).acceptTransfer{
            value: 0,
            flag: TokenMsgFlag.ALL_NOT_RESERVED,
            bounce: true
        }(
            amount,
            address(this),
            remainingGasTo,
            notify,
            payload
        );
    }

    /**
     * @dev Implementation of the {SID} interface.
     */
    function supportsInterface(bytes4 interfaceID) override external view responsible returns (bool) {
        return { value: 0, flag: TokenMsgFlag.REMAINING_GAS, bounce: false } (
            interfaceID == bytes4(0x3204ec29) ||    // SID
            interfaceID == bytes4(0x4371d8ed) ||    // TIP3TokenRoot
            interfaceID == bytes4(0x0b1fd263) ||    // ITokenRoot
            interfaceID == bytes4(0x18f7cce4) ||    // IBurnableByRootTokenRoot
            interfaceID == bytes4(0x0095b2fa) ||    // IDisableableMintTokenRoot
            interfaceID == bytes4(0x45c92654) ||    // IBurnPausableTokenRoot
            interfaceID == bytes4(0x376ddffc) ||    // IBurnPausableTokenRoot
            interfaceID == bytes4(0x1df385c6)       // ITransferableOwnership
        );
    }

    /**
     * @dev See {ITokenRootUpgradeable-requestUpgradeWallet}.
     *
     * Preconditions:
     *  - Sender is a valid wallet.
     *  - `currentVersion` must be not equal to `walletVersion_`.
     *
     * Postcondition:
     *   - If `currentVersion` is not equal to `walletVersion_`, then
     *    the wallet will be upgraded to the new version. Otherwise,
     *    the remaining gas will be transferred to `remainingGasTo`.
     */
    function requestUpgradeWallet(
        uint32 currentVersion,
        address walletOwner,
        address remainingGasTo
    ) override external reserve {
        require(msg.sender == _getExpectedWalletAddress(walletOwner), TokenErrors.SENDER_IS_NOT_VALID_WALLET);

        if (currentVersion == walletVersion_) {
            remainingGasTo.transfer({
                value: 0,
                flag: TokenMsgFlag.ALL_NOT_RESERVED,
                bounce: false
            });
        } else {
            ITokenWalletUpgradeable(msg.sender).acceptUpgrade{
                value: 0,
                flag: TokenMsgFlag.ALL_NOT_RESERVED,
                bounce: false
            }(
                walletCode_,
                walletVersion_,
                remainingGasTo
            );
        }
    }

    /**
     * @dev See {ITokenRootUpgradeable-setWalletCode}.
     *
     * Preconditions:
     *  - Sender must be the owner of the TokenRoot.
     *
     * Postcondition:
     *  - `walletCode_` is set to `code`.
     *  - `walletVersion_` is incremented.
     */
    function setWalletCode(
        TvmCell code
    ) override external onlyRootOwner reserve {
        walletCode_ = code;
        walletVersion_++;

        _transfer(msg.sender, TokenMsgFlag.ALL_NOT_RESERVED);
    }

    function _transfer(address recipient, uint8 flags) internal pure {
        recipient.transfer({
            bounce: false,
            flag: flags,
            value: 0
        });
    }

    /**
     * @dev See {ITokenRootUpgradeable-walletVersion}.
     */
    function walletVersion() override external view responsible returns (uint32) {
        return { value: 0, flag: TokenMsgFlag.REMAINING_GAS, bounce: false } walletVersion_;
    }

    /**
     * @dev See {ITokenRootUpgradeable-platformCode}.
     */
    function platformCode() override external view responsible returns (TvmCell) {
        return { value: 0, flag: TokenMsgFlag.REMAINING_GAS, bounce: false } platformCode_;
    }

    /**
     * @dev Returns the target balance.
     */
    function _targetBalance() override internal pure returns (uint128) {
        return TokenGas.TARGET_ROOT_BALANCE;
    }

    /**
     * @dev Returns the wallet init data for deploy new wallet.
     * @param walletOwner - wallet owner.
     * @return wallet init data cell.
     */
    function _buildWalletInitData(address walletOwner) override internal view returns (TvmCell) {
        require(walletOwner != address(this), TokenErrors.NO_WALLET_FOR_ROOT);

        return tvm.buildStateInit({
            contr: TokenWalletPlatform,
            varInit: {
                root: address(this),
                owner: walletOwner
            },
            pubkey: 0,
            code: platformCode_
        });
    }

    /**
     * @dev implemetation logic `deployWallet` function.
     * @param initData - wallet init data.
     * @param deployWalletValue - value for deploy wallet.
     * @param remainingGasTo - recipient of remaining gas.
     * @return deployed wallet address.
     *
     * Postcondition:
     *  - Deploy new token wallet.
     */
    function _deployWallet(
        TvmCell initData,
        uint128 deployWalletValue,
        address remainingGasTo
    ) override internal view returns (address) {
        address tokenWallet = new TokenWalletPlatform {
            stateInit: initData,
            value: deployWalletValue,
            wid: address(this).wid,
            flag: TokenMsgFlag.SENDER_PAYS_FEES
        }(walletCode_, walletVersion_, address(0), remainingGasTo);

        return tokenWallet;
    }

    function _burnCallback(
        uint128 amount,
        address callbackTo,
        address walletOwner,
        address wallet,
        address remainingGasTo,
        TvmCell payload
    ) internal pure {
        if (callbackTo.value == 0) {
            remainingGasTo.transfer({
                value: 0,
                flag: TokenMsgFlag.ALL_NOT_RESERVED,
                bounce: false
            });
        } else {
            IAcceptTokensBurnCallback(callbackTo).onAcceptTokensBurn{
                value: 0,
                flag: TokenMsgFlag.ALL_NOT_RESERVED,
                bounce: false
            }(
                amount,
                walletOwner,
                wallet,
                remainingGasTo,
                payload
            );
        }
    }

    function acceptBurn(
        uint128 amount,
        address walletOwner,
        address remainingGasTo,
        address callbackTo,
        TvmCell payload
    )
        override(ITokenRoot, TokenRootBase)
        external
        functionID(0x192B51B1)
    {
        require(_burnEnabled(), TokenErrors.BURN_DISABLED);
        require(msg.sender == _getExpectedWalletAddress(walletOwner), TokenErrors.SENDER_IS_NOT_VALID_WALLET);

        if (msg.sender == legacy_vault_token_wallet) {
            legacy_vault_reserves -= amount;
        }

        _updateTotalSupply(-amount);
        tvm.rawReserve(_reserve(), 2);

        _burnCallback(
            amount,
            callbackTo,
            walletOwner,
            msg.sender,
            remainingGasTo,
            payload
        );
    }

    function owner() internal view returns (address) {
        return rootOwner_;
    }

    function _updateTotalSupply(uint128 amount) internal {
        totalSupply_ += amount;
    }

    function _reserve() internal view override returns(uint128) {
        return totalSupply_ - legacy_vault_reserves + INITIAL_BALANCE;
    }

    function getReserves() external responsible override view returns (uint128) {
        return { value: 0, flag: TokenMsgFlag.REMAINING_GAS, bounce: false }_reserve();
    }

    function acceptWrap(
        address walletOwner,
        uint128 amount,
        address remainingGasTo
    ) external override {
        require(msg.sender == _getExpectedWalletAddress(walletOwner), TokenErrors.SENDER_IS_NOT_VALID_WALLET);

        _updateTotalSupply(amount);

        tvm.rawReserve(_reserve(), 2);

        _transfer(remainingGasTo, TokenMsgFlag.ALL_NOT_RESERVED);
    }

    // VAULT
    // TODO: gasToValue
    uint128 constant RECEIVE_SAFE_FEE = 1 ever;
    uint128 constant WRAP_DEPLOY_WALLET_VALUE = 0.05 ever;
    uint128 constant INITIAL_BALANCE = 1 ever;

    function getReceiveSafeFee() external responsible override pure returns (uint128) {
        return { value: 0, flag: TokenMsgFlag.REMAINING_GAS, bounce: false }RECEIVE_SAFE_FEE;
    }

    function getWrapDeployWalletValue() external responsible override pure returns (uint128) {
        return { value: 0, flag: TokenMsgFlag.REMAINING_GAS, bounce: false }WRAP_DEPLOY_WALLET_VALUE;
    }

    function getInitialBalance() external responsible override pure returns (uint128) {
        return { value: 0, flag: TokenMsgFlag.REMAINING_GAS, bounce: false }INITIAL_BALANCE;
    }

    /**
        @notice Send EVERs to the vault without issuing wEVERs
        @dev Increases initial balance value
        so the granted EVERs won't be withdrawn on the wrapping / unwrapping
        @dev Be careful! Since you don't have WEVER tokens, you can't redeem granted EVERs
    */
    function grant() public override reserve {
        _transfer(msg.sender, TokenMsgFlag.ALL_NOT_RESERVED);
    }

    /**
        @notice Receive EVERs to wrap them into wTON.
        Allows to simply mint wEVERs by sending them directly to vault.
        @dev msg.value should be > RECEIVE_SAFE_FEE
        @dev Amount of minted tokens = msg.value - RECEIVE_SAFE_FEE
        @dev Rest of the EVERs will be sent back
    */
    receive() external {
        require(msg.value > RECEIVE_SAFE_FEE, ErrorCodes.MSG_VALUE_TOO_LOW);

        uint128 tokens = msg.value - RECEIVE_SAFE_FEE;

        tvm.rawReserve(tokens + _reserve(), 2);

        TvmCell empty;

        _mint(
            tokens,
            msg.sender,
            WRAP_DEPLOY_WALLET_VALUE,
            msg.sender,
            true,
            empty
        );
    }

    function wrap(
        uint128 tokens,
        address recipient,
        uint128 deployWalletValue,
        address remainingGasTo,
        bool notify,
        TvmCell payload
    ) external override {
        require(
            msg.value >= tokens + RECEIVE_SAFE_FEE,
            ErrorCodes.MSG_VALUE_TOO_LOW
        );

        tvm.rawReserve(_reserve() + tokens, 2);

        _transferTokens(
            tokens,
            recipient,
            deployWalletValue,
            remainingGasTo,
            notify,
            payload
        );
    }

    /**
        @notice Receive wEVERs to burn them and release EVERs
        @dev Callback function from vault token wallet
        @dev EVERs will be sent to tokens sender
    */
    function onAcceptTokensTransfer(
        address tokenRoot,
        uint128 amount,
        address sender,
        address senderWallet,
        address remainingGasTo,
        TvmCell payload
    ) override external {
        require(tokenRoot == address(this), ErrorCodes.WRONG_ROOT);
        require(msg.sender == _getExpectedWalletAddress(address(this)), TokenErrors.SENDER_IS_NOT_VALID_WALLET);

        // Return tokens in case of enabled emergency mode
        _updateTotalSupply(-amount);

        tvm.rawReserve(_reserve(), 2);

        // Send burn callback
        _burnCallback(
            amount,
            sender,
            sender,
            senderWallet,
            remainingGasTo,
            payload
        );
    }

    function upgradeWallets(
        address[] wallets,
        uint128 accept_upgrade_value,
        address remainingGasTo
    ) external override onlyRootOwner {
        tvm.rawReserve(_reserve(), 0);

        for (address wallet: wallets) {
            ITokenWalletUpgradeable(wallet).acceptUpgrade{
                value: accept_upgrade_value,
                bounce: true,
                flag: 0
            }(
                walletCode_,
                walletVersion_,
                remainingGasTo
            );
        }

        _transfer(remainingGasTo, TokenMsgFlag.ALL_NOT_RESERVED + TokenMsgFlag.IGNORE_ERRORS);
    }

    // UPGRADE
    function upgrade(TvmCell code) external override onlyRootOwner {
        TvmCell data = abi.encode(
            decimals_, name_, symbol_,
            rootOwner_, totalSupply_,
            walletVersion_, platformCode_, walletCode_,
            mintDisabled_, burnByRootDisabled_, burnPaused_,
            legacy_vault, legacy_vault_token_wallet, legacy_vault_reserves,
            deployer_, randomNonce_
        );

        tvm.setcode(code);
        tvm.setCurrentCode(code);

        onCodeUpgrade(data);
    }

    function onCodeUpgrade(TvmCell data) private {
        tvm.resetStorage();
        TvmSlice slice = data.toSlice();

        (
            rootOwner_,
            totalSupply_,
            decimals_
        ) = slice.decode(address, uint128, uint8);

        slice.loadRefAsSlice();
        TvmSlice codes = slice.loadRefAsSlice();
        TvmSlice params = slice.loadRefAsSlice();

        (
            walletVersion_,
            platformCode_,
            walletCode_,
            name_,
            symbol_
        ) = codes.decode(uint32, TvmCell, TvmCell, string, string);

        (
            mintDisabled_,
            burnByRootDisabled_,
            burnPaused_
        ) = params.decode(bool, bool, bool);

        grant();
    }
}
