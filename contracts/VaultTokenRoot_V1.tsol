pragma ton-solidity >= 0.57.1;

import "tip3/abstract/TokenRootTransferableOwnershipBase.tsol";
import "tip3/abstract/TokenRootBurnPausableBase.tsol";
import "tip3/abstract/TokenRootBurnableByRootBase.tsol";
import "tip3/abstract/TokenRootDisableableMintBase.tsol";
import "tip3/interfaces/IAcceptTokensTransferCallback.tsol";

import "tip3/interfaces/ITokenRootUpgradeable.tsol";
import "tip3/interfaces/ITokenWalletUpgradeable.tsol";
import "tip3/interfaces/IVersioned.tsol";
import "tip3/libraries/TokenErrors.tsol";
import "tip3/libraries/TokenMsgFlag.tsol";
import "tip3/libraries/TokenGas.tsol";
import "tip3/TokenWalletPlatform.tsol";

import "./interfaces/IVaultTokenRoot_V1.tsol";
import "./libraries/ErrorCodes.tsol";

import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";


contract VaultTokenRoot_V1 is
    TokenRootTransferableOwnershipBase,
    TokenRootBurnPausableBase,
    TokenRootBurnableByRootBase,
    TokenRootDisableableMintBase,
    ITokenRootUpgradeable,
    IVaultTokenRoot_V1,
    IAcceptTokensTransferCallback
{
    uint256 static randomNonce_;
    address static deployer_;

    TvmCell static platformCode_;
    uint32 walletVersion_;

    modifier cashBack() {
        tvm.rawReserve(address(this).balance - msg.value, 2);
        _;
        msg.sender.transfer({ value: 0, flag: 129 });
    }

    constructor() public {
        if (msg.pubkey() != 0) {
            require(msg.pubkey() == tvm.pubkey() && deployer_.value == 0, TokenErrors.WRONG_ROOT_OWNER);
            tvm.accept();
        } else {
            require(deployer_.value != 0 && msg.sender == deployer_ ||
                deployer_.value == 0 && msg.sender == rootOwner_, TokenErrors.WRONG_ROOT_OWNER);
        }

        totalSupply_ = 0;
        mintDisabled_ = false;
        burnByRootDisabled_ = false;
        burnPaused_ = false;
        walletVersion_ = 1;

        tvm.rawReserve(_targetBalance(), 0);

        _deployWallet(
            _buildWalletInitData(address(this)),
            WRAP_DEPLOY_WALLET_VALUE,
            rootOwner_
        );
    }

    /**
     * @dev Implementation of the {SID} interface.
     */
    function supportsInterface(bytes4 interfaceID) override external view responsible returns (bool) {
        return { value: 0, flag: TokenMsgFlag.REMAINING_GAS, bounce: false } (
            interfaceID == bytes4(0x3204ec29) ||    // SID
            interfaceID == bytes4(0x4371d8ed) ||    // TIP3TokenRoot
            interfaceID == bytes4(0x0b1fd263) ||    // ITokenRoot
            interfaceID == bytes4(0x18f7cce4) ||    // IBurnableByRootTokenRoot
            interfaceID == bytes4(0x0095b2fa) ||    // IDisableableMintTokenRoot
            interfaceID == bytes4(0x45c92654) ||    // IBurnPausableTokenRoot
            interfaceID == bytes4(0x376ddffc) ||    // IBurnPausableTokenRoot
            interfaceID == bytes4(0x1df385c6)       // ITransferableOwnership
        );
    }

    /**
     * @dev See {ITokenRootUpgradeable-requestUpgradeWallet}.
     *
     * Preconditions:
     *  - Sender is a valid wallet.
     *  - `currentVersion` must be not equal to `walletVersion_`.
     *
     * Postcondition:
     *   - If `currentVersion` is not equal to `walletVersion_`, then
     *    the wallet will be upgraded to the new version. Otherwise,
     *    the remaining gas will be transferred to `remainingGasTo`.
     */
    // TODO: remove request upgrade functions
    function requestUpgradeWallet(
        uint32 currentVersion,
        address walletOwner,
        address remainingGasTo
    ) override external {
        require(msg.sender == _getExpectedWalletAddress(walletOwner), TokenErrors.SENDER_IS_NOT_VALID_WALLET);

        _reserveVaultTreasuries();

        if (currentVersion == walletVersion_) {
            remainingGasTo.transfer({
                value: 0,
                flag: TokenMsgFlag.ALL_NOT_RESERVED,
                bounce: false
            });
        } else {
            ITokenWalletUpgradeable(msg.sender).acceptUpgrade{
                value: 0,
                flag: TokenMsgFlag.ALL_NOT_RESERVED,
                bounce: false
            }(
                walletCode_,
                walletVersion_,
                remainingGasTo
            );
        }
    }

    /**
     * @dev See {ITokenRootUpgradeable-setWalletCode}.
     *
     * Preconditions:
     *  - Sender must be the owner of the TokenRoot.
     *
     * Postcondition:
     *  - `walletCode_` is set to `code`.
     *  - `walletVersion_` is incremented.
     */
    function setWalletCode(
        TvmCell code
    ) override external onlyRootOwner cashBack {
        walletCode_ = code;
        walletVersion_++;
    }

    /**
     * @dev See {ITokenRootUpgradeable-walletVersion}.
     */
    function walletVersion() override external view responsible returns (uint32) {
        return { value: 0, flag: TokenMsgFlag.REMAINING_GAS, bounce: false } walletVersion_;
    }

    /**
     * @dev See {ITokenRootUpgradeable-platformCode}.
     */
    function platformCode() override external view responsible returns (TvmCell) {
        return { value: 0, flag: TokenMsgFlag.REMAINING_GAS, bounce: false } platformCode_;
    }

    /**
     * @dev Returns the target balance.
     */
    function _targetBalance() override internal pure returns (uint128) {
        return TokenGas.TARGET_ROOT_BALANCE;
    }

    /**
     * @dev Returns the wallet init data for deploy new wallet.
     * @param walletOwner - wallet owner.
     * @return wallet init data cell.
     */
    function _buildWalletInitData(address walletOwner) override internal view returns (TvmCell) {
        return tvm.buildStateInit({
            contr: TokenWalletPlatform,
            varInit: {
                root: address(this),
                owner: walletOwner
            },
            pubkey: 0,
            code: platformCode_
        });
    }

    /**
     * @dev implemetation logic `deployWallet` function.
     * @param initData - wallet init data.
     * @param deployWalletValue - value for deploy wallet.
     * @param remainingGasTo - recipient of remaining gas.
     * @return deployed wallet address.
     *
     * Postcondition:
     *  - Deploy new token wallet.
     */
    function _deployWallet(
        TvmCell initData,
        uint128 deployWalletValue,
        address remainingGasTo
    ) override internal view returns (address) {
        address tokenWallet = new TokenWalletPlatform {
            stateInit: initData,
            value: deployWalletValue,
            wid: address(this).wid,
            flag: TokenMsgFlag.SENDER_PAYS_FEES
        }(walletCode_, walletVersion_, address(0), remainingGasTo);

        return tokenWallet;
    }

    function _burnCallback(
        uint128 amount,
        address callbackTo,
        address walletOwner,
        address wallet,
        address remainingGasTo,
        TvmCell payload
    ) internal pure {
        if (callbackTo.value == 0) {
            remainingGasTo.transfer({
                value: 0,
                flag: TokenMsgFlag.ALL_NOT_RESERVED + TokenMsgFlag.IGNORE_ERRORS,
                bounce: false
            });
        } else {
            IAcceptTokensBurnCallback(callbackTo).onAcceptTokensBurn{
                value: 0,
                flag: TokenMsgFlag.ALL_NOT_RESERVED + TokenMsgFlag.IGNORE_ERRORS,
                bounce: false
            }(
                amount,
                walletOwner,
                wallet,
                remainingGasTo,
                payload
            );
        }
    }

    function acceptBurn(
        uint128 amount,
        address walletOwner,
        address remainingGasTo,
        address callbackTo,
        TvmCell payload
    )
        override(ITokenRoot, TokenRootBase)
        external
        functionID(0x192B51B1)
    {
        require(_burnEnabled(), TokenErrors.BURN_DISABLED);
        require(msg.sender == _getExpectedWalletAddress(walletOwner), TokenErrors.SENDER_IS_NOT_VALID_WALLET);

        _updateTotalSupply(-amount);
        _reserveVaultTreasuries();

        _burnCallback(
            amount,
            callbackTo,
            walletOwner,
            msg.sender,
            remainingGasTo,
            payload
        );
    }

    function owner() internal view returns (address) {
        return rootOwner_;
    }

    function _updateTotalSupply(uint128 amount) internal {
        totalSupply_ += amount;
    }

    function _treasuries() internal view returns(uint128) {
        return totalSupply_ + INITIAL_BALANCE;
    }

    function treasuries() external view returns (uint128) {
        return _treasuries();
    }

    function __reserve(uint128 amount) internal view {
        tvm.rawReserve(amount, 2);
    }

    function _reserveVaultTreasuries() internal view {
        __reserve(_treasuries());
    }

    function acceptWrap(
        address walletOwner,
        uint128 amount,
        address remainingGasTo
    ) external override {
        require(msg.sender == _getExpectedWalletAddress(walletOwner), TokenErrors.SENDER_IS_NOT_VALID_WALLET);

        _updateTotalSupply(amount);
        _reserveVaultTreasuries();

        remainingGasTo.transfer({
            value: 0,
            flag: TokenMsgFlag.ALL_NOT_RESERVED,
            bounce: false
        });
    }

    // VAULT
    uint128 constant public RECEIVE_SAFE_FEE = 1 ever;
    uint128 constant public WRAP_DEPLOY_WALLET_VALUE = 0.05 ever;
    uint128 constant public INITIAL_BALANCE = 1 ever;

    /**
        @notice Send EVERs to the vault without issuing wEVERs
        @dev Increases initial balance value
        so the granted EVERs won't be withdrawn on the wrapping / unwrapping
        @dev Be careful! Since you don't have WEVER tokens, you can't redeem granted EVERs
    */
    function grant() external override {
        _reserveVaultTreasuries();

        msg.sender.transfer({
            value: 0,
            flag: 128,
            bounce: false
        });
    }

    /**
        @notice Receive EVERs to wrap them into wTON.
        Allows to simply mint wEVERs by sending them directly to vault.
        @dev msg.value should be > RECEIVE_SAFE_FEE
        @dev Amount of minted tokens = msg.value - RECEIVE_SAFE_FEE
        @dev Rest of the EVERs will be sent back
    */
    receive() external {
        require(msg.value > RECEIVE_SAFE_FEE, ErrorCodes.MSG_VALUE_TOO_LOW);

        uint128 tokens = msg.value - RECEIVE_SAFE_FEE;

        __reserve(tokens + _treasuries());

        TvmCell empty;

        _mint(
            tokens,
            msg.sender,
            WRAP_DEPLOY_WALLET_VALUE,
            msg.sender,
            true,
            empty
        );
    }

    function wrap(
        uint128 tokens,
        address recipient,
        uint128 deployWalletValue,
        address remainingGasTo,
        bool notify,
        TvmCell payload
    ) external override {
        require(
            msg.value >= tokens + RECEIVE_SAFE_FEE,
            ErrorCodes.MSG_VALUE_TOO_LOW
        );

        __reserve(_treasuries() + tokens);

        _mint(
            tokens,
            recipient,
            deployWalletValue,
            remainingGasTo,
            notify,
            payload
        );
    }

    /**
        @notice Receive wEVERs to burn them and release EVERs
        @dev Callback function from vault token wallet
        @dev EVERs will be sent to tokens sender
    */
    function onAcceptTokensTransfer(
        address tokenRoot,
        uint128 amount,
        address sender,
        address senderWallet,
        address remainingGasTo,
        TvmCell payload
    ) override external {
        require(tokenRoot == address(this), ErrorCodes.WRONG_ROOT);
        require(msg.sender == _getExpectedWalletAddress(address(this)), TokenErrors.SENDER_IS_NOT_VALID_WALLET);

        // Return tokens in case of enabled emergency mode
        _updateTotalSupply(-amount);
        _reserveVaultTreasuries();

        // Send burn callback
        _burnCallback(
            amount,
            sender,
            sender,
            senderWallet,
            remainingGasTo,
            payload
        );
    }

    function upgradeWallets(
        address[] wallets,
        uint128 accept_upgrade_value
    ) external override onlyRootOwner {
        _reserveVaultTreasuries();

        for (address wallet: wallets) {
            ITokenWalletUpgradeable(wallet).acceptUpgrade{
                value: accept_upgrade_value,
                bounce: true,
                flag: 0
            }(
                walletCode_,
                walletVersion_,
                msg.sender
            );
        }
    }

    // UPGRADE
    function upgrade(TvmCell code) external override onlyRootOwner {
        TvmCell data = abi.encode(
            rootOwner_, totalSupply_,
            decimals_, name_, symbol_,
            walletVersion_, platformCode_, walletCode_,
            mintDisabled_, burnByRootDisabled_, burnPaused_
        );

        tvm.setcode(code);
        tvm.setCurrentCode(code);

        onCodeUpgrade(data);
    }

    function onCodeUpgrade(TvmCell data) private {
        tvm.resetStorage();
        TvmSlice slice = data.toSlice();

        (
            rootOwner_,
            totalSupply_,
            decimals_
        ) = slice.decode(address, uint128, uint8);

        slice.loadRefAsSlice();
        TvmSlice codes = slice.loadRefAsSlice();
        TvmSlice params = slice.loadRefAsSlice();

        (
            walletVersion_,
            platformCode_,
            walletCode_,
            name_,
            symbol_
        ) = codes.decode(uint32, TvmCell, TvmCell, string, string);

        (
            mintDisabled_,
            burnByRootDisabled_,
            burnPaused_
        ) = params.decode(bool, bool, bool);
    }
}
